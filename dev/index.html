<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MRphy.jl Documentation · MRphy.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MRphy.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MRphy.jl Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Modules"><span>Modules</span></a></li><li class="toplevel"><a class="tocitem" href="#Constants"><span>Constants</span></a></li><li class="toplevel"><a class="tocitem" href="#Types"><span>Types</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#SteadyStates"><span>SteadyStates</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MRphy.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MRphy.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tianrluo/MRphy.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MRphy.jl-Documentation"><a class="docs-heading-anchor" href="#MRphy.jl-Documentation">MRphy.jl Documentation</a><a id="MRphy.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#MRphy.jl-Documentation" title="Permalink"></a></h1><h1 id="Modules"><a class="docs-heading-anchor" href="#Modules">Modules</a><a id="Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Modules" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MRphy" href="#MRphy"><code>MRphy</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>General Comments:</strong></p><ul><li><code>nM</code>, number of spins, as magnetic spin vectors are often denoted as 𝑀.</li><li><code>nT</code>, number of steps/time-points.</li></ul><p><a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.jl</code></a> related:</p><ul><li><code>𝐁 = 𝐌*𝐈^-1*𝐓^-2</code>, dimension of magnetic field strength.</li><li><code>𝐅 = 𝐓^-1</code>, dimension of temporal frequency.</li><li><code>𝐊 = 𝐋^-1</code>, dimension of spatial frequency.</li><li><code>𝚪 = 𝐅/𝐁</code>, dimension of gyro ratio.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.utils" href="#MRphy.utils"><code>MRphy.utils</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Some utilities functions routinely used in MR simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/utils.jl#L1-L3">source</a></section></article><p>See <a href="#Utilities">Utilities</a></p><article class="docstring"><header><a class="docstring-binding" id="MRphy.SteadyStates" href="#MRphy.SteadyStates"><code>MRphy.SteadyStates</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Some steady state properties of common sequences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/SteadyStates.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SteadyStates.Signal" href="#MRphy.SteadyStates.Signal"><code>MRphy.SteadyStates.Signal</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Analytical expressions of common steady states sequences signals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/SteadyStates.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SteadyStates.RFSpoiling" href="#MRphy.SteadyStates.RFSpoiling"><code>MRphy.SteadyStates.RFSpoiling</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Tools for simulating RF spoiling in gradient echo sequences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/SteadyStates.jl#L98-L100">source</a></section></article><p>See <a href="#SteadyStates">SteadyStates</a></p><h1 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MRphy.γ¹H" href="#MRphy.γ¹H"><code>MRphy.γ¹H</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const γ¹H = 4257.6u&quot;Hz/Gauss&quot;</code></pre><p>Gyromagnetic ratio of water proton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L172-L175">source</a></section></article><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MRphy.AbstractPulse" href="#MRphy.AbstractPulse"><code>MRphy.AbstractPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstract type for pulses.</p><p>See also: <a href="#MRphy.Pulse"><code>Pulse</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.AbstractSpinArray" href="#MRphy.AbstractSpinArray"><code>MRphy.AbstractSpinArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This type keeps the essentials of magnetic spins. Its instance struct must contain all fields listed listed in the exemplary struct <code>SpinArray</code>.</p><p><strong>Misc</strong></p><p>Might make <code>AbstractSpinArray &lt;: AbstractArray</code> in a future version</p><p>See also: <a href="#MRphy.SpinArray"><code>SpinArray</code></a>, <a href="#MRphy.AbstractSpinCube"><code>AbstractSpinCube</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L65-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.AbstractSpinBolus" href="#MRphy.AbstractSpinBolus"><code>MRphy.AbstractSpinBolus</code></a> — <span class="docstring-category">Type</span></header><section><div><p><em>UNDER CONSTRUCTION</em></p><p><code>AbstractSpinBolus &lt;: AbstractSpinArray</code>. This type inherits <code>AbstractSpinArray</code> as a field. Its instance struct must contain all fields listed in the exemplary struct <code>SpinBolus</code>.</p><p>See also: <a href="#MRphy.AbstractSpinArray"><code>AbstractSpinArray</code></a>, <a href="#MRphy.SpinBolus"><code>SpinBolus</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L236-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.AbstractSpinCube" href="#MRphy.AbstractSpinCube"><code>MRphy.AbstractSpinCube</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AbstractSpinCube &lt;: AbstractSpinArray</code>. This type inherits <code>AbstractSpinArray</code> as a field. Its instance struct must contain all fields listed in the exemplary struct <code>SpinCube</code>.</p><p>See also: <a href="#MRphy.AbstractSpinArray"><code>AbstractSpinArray</code></a>, <a href="#MRphy.SpinCube"><code>SpinCube</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L155-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.B0D" href="#MRphy.B0D"><code>MRphy.B0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">B0D{T&lt;:Real} = Quantity{T, 𝐁}</code></pre><p>Type of magetic field strength. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;Gauss&quot;)::B0D
1 Gauss</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.F0D" href="#MRphy.F0D"><code>MRphy.F0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">F0D{T&lt;:Real} = Quantity{T, 𝐅}</code></pre><p>Type of temporal frequency. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;s^-1&quot;)::F0D
1 s^-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L118-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.GR0D" href="#MRphy.GR0D"><code>MRphy.GR0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GR0D{T&lt;:Real} = Quantity{T, 𝐁/𝐋}</code></pre><p>Type of magnetic gradient. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;Gauss/cm&quot;)::GR0D
1 Gauss cm^-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L131-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.K0D" href="#MRphy.K0D"><code>MRphy.K0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">K0D{T&lt;:Real} = Quantity{T, 𝐊}</code></pre><p>Type of spatial frequency. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;cm^-1&quot;)::K0D
1 cm^-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.L0D" href="#MRphy.L0D"><code>MRphy.L0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">L0D{T&lt;:Real} = Quantity{T, 𝐋}</code></pre><p>Type of length. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;cm&quot;)::L0D
1 cm</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.Pulse" href="#MRphy.Pulse"><code>MRphy.Pulse</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct for typical MR pulses: <code>Pulse &lt;: AbstractPulse</code>.</p><p><strong>Fields:</strong></p><p><em>Mutable</em>:</p><ul><li><code>rf::TypeND(RF0D, [1,2])</code> (nT,) or (nT, nCoils).</li><li><code>gr::TypeND(GR0D, [2])</code> (nT, 3), where 3 accounts for x-y-z channels.</li><li><code>dt::T0D</code> (1,), simulation temporal step size, i.e., dwell time.</li><li><code>des::String</code>, an description of the pulse to be constructed.</li></ul><p>See also: <a href="#MRphy.AbstractPulse"><code>AbstractPulse</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.Pulse" href="#MRphy.Pulse"><code>MRphy.Pulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pulse(rf, gr; dt=(4e-6)u&quot;s&quot;, des=&quot;generic pulse&quot;)</code></pre><p>Create <code>Pulse</code> object with prescribed parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L40-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.RF0D" href="#MRphy.RF0D"><code>MRphy.RF0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RF0D{T&lt;:Complex} = Quantity{T, 𝐁}</code></pre><p>Type of magnetic RF. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; ((1+1im)u&quot;Gauss&quot;)::RF0D
1 + 1im Gauss</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L157-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SL0D" href="#MRphy.SL0D"><code>MRphy.SL0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SL0D{T&lt;:Real} = Quantity{T, 𝐁/𝐋/𝐓}</code></pre><p>Type of magnetic gradient. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;Gauss/cm/s&quot;)::SL0D
1 Gauss cm^-1 s^-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L144-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SpinArray" href="#MRphy.SpinArray"><code>MRphy.SpinArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An exemplary struct instantiating <code>AbstractSpinArray</code>.</p><p><strong>Fields:</strong></p><p><em>Immutable</em>:</p><ul><li><code>dim::Dims</code> (nd,): <code>nM ← prod(dim)</code>, dimension of the object.</li><li><code>mask::BitArray</code> (nx,(ny,(nz))): Mask for <code>M</code>, <code>dim == (nx,(ny,(nz)))</code></li></ul><p><em>Mutable</em>:</p><ul><li><code>T1::TypeND(T0D, [0,1])</code> (1,) or (nM,): Longitudinal relaxation coeff.</li><li><code>T2::TypeND(T0D, [0,1])</code> (1,) or (nM,): Transversal relaxation coeff.</li><li><code>γ::TypeND(Γ0D, [0,1])</code>  (1,) or (nM,): Gyromagnetic ratio.</li><li><code>M::TypeND(Real, [2])</code>   (<code>count(mask)</code>, 3):  Magnetic spins, (𝑀x,𝑀y,𝑀z).</li></ul><p><strong>Notes:</strong></p><p>off-resonance, <code>Δf</code>, and locations, <code>loc</code>, are intentionally unincluded, as they are not intrinsic to spins, and can change over time. Unincluding them allows extensional subtypes specialized for, e.g., arterial spin labelling.</p><p>See also: <a href="#MRphy.AbstractSpinArray"><code>AbstractSpinArray</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L96-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SpinArray" href="#MRphy.SpinArray"><code>MRphy.SpinArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpinArray(dim::Dims; T1=1.47u&quot;s&quot;, T2=0.07u&quot;s&quot;, γ=γ¹H, M=[0. 0. 1.])</code></pre><p>Create <code>SpinArray</code> object with prescribed parameters, with <code>mask = trues(dim)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L146-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SpinArray-Tuple{BitArray}" href="#MRphy.SpinArray-Tuple{BitArray}"><code>MRphy.SpinArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SpinArray(mask::BitArray; T1=1.47u&quot;s&quot;, T2=0.07u&quot;s&quot;, γ=γ¹H, M=[0. 0. 1.])</code></pre><p>Create <code>SpinArray</code> object with prescribed parameters, with <code>dim = size(mask)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L131-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SpinBolus" href="#MRphy.SpinBolus"><code>MRphy.SpinBolus</code></a> — <span class="docstring-category">Type</span></header><section><div><p><em>UNDER CONSTRUCTION</em></p><p>An exemplary struct instantiating <code>AbstractSpinBolus</code>, designed to model a set of moving spins, e.g., a blood bolus in ASL context.</p><p>See also: <a href="#MRphy.AbstractSpinBolus"><code>AbstractSpinBolus</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L260-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SpinCube" href="#MRphy.SpinCube"><code>MRphy.SpinCube</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An exemplary struct instantiating <code>AbstractSpinCube</code>, designed to model a set of regularly spaced spins, e.g., a volume.</p><p><strong>Fields:</strong></p><p><em>Immutable</em>:</p><ul><li><code>spinarray::AbstractSpinArray</code> (1,): inherited <code>AbstractSpinArray</code> struct</li><li><code>fov ::TypeND(L0D, [2])</code> (1, 3): field of view.</li><li><code>ofst::TypeND(L0D, [2])</code> (1, 3): fov offset from magnetic field iso-center.</li><li><code>loc ::TypeND(L0D, [2])</code> (nM, 3): location of spins.</li></ul><p><em>Mutable</em>:</p><ul><li><code>Δf::TypeND(F0D, [0,1])</code> (1,) or (nM,): off-resonance map.</li></ul><p>See also: <a href="#MRphy.AbstractSpinCube"><code>AbstractSpinCube</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L183-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SpinCube-Tuple{BitArray{3},AbstractArray{D,2} where D&lt;:(Unitful.Quantity{T,𝐋,U} where U where T&lt;:Real)}" href="#MRphy.SpinCube-Tuple{BitArray{3},AbstractArray{D,2} where D&lt;:(Unitful.Quantity{T,𝐋,U} where U where T&lt;:Real)}"><code>MRphy.SpinCube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spincube = SpinCube(mask::BitArray{3}, fov; ofst, Δf, T1, T2, γ)</code></pre><p><code>dim</code>, <code>mask</code>, <code>T1</code>, <code>T2</code>, and <code>γ</code> are passed to <code>SpinArray</code> constructors.</p><p>Create <code>SpinCube</code> object with prescribed parameters, with <code>dim = size(mask)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SpinCube-Tuple{Tuple{Int64,Int64,Int64},Vararg{Any,N} where N}" href="#MRphy.SpinCube-Tuple{Tuple{Int64,Int64,Int64},Vararg{Any,N} where N}"><code>MRphy.SpinCube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spincube = SpinCube(dim::Dims{3}, fov; ofst, Δf, T1, T2, γ)</code></pre><p>Create <code>SpinCube</code> object with prescribed parameters, with <code>mask = trues(dim)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L227-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.T0D" href="#MRphy.T0D"><code>MRphy.T0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T0D{T&lt;:Real} = Quantity{T, 𝐓}</code></pre><p>Type of time. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;s&quot;)::T0D
1 s</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L105-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.Γ0D" href="#MRphy.Γ0D"><code>MRphy.Γ0D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Γ0D{T&lt;:Real} = Quantity{T, 𝚪}</code></pre><p>Type of gyro magnetic ratio. Based on <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful.Quantity</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; (1u&quot;Hz/Gauss&quot;)::Γ0D
1 Hz Gauss^-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L66-L76">source</a></section></article><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MRphy.TypeND" href="#MRphy.TypeND"><code>MRphy.TypeND</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">TypeND(T,Ns) = Union{AbstractArray{&lt;:T,Ns[1]}, AbstractArray{&lt;:T,Ns[2]},...}</code></pre><p>Sugar for creating <code>Union</code>{<code>&lt;:T</code> typed array of different dimensions}.</p><p><strong>Usage</strong></p><p><em>INPUTS</em>:</p><ul><li><code>T::Type</code> (1,), the underlying type of the union.</li><li><code>Ns::Array{Int64,1}</code> (# diff dims,), an array of wanted dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L27-L35">source</a></section><section><div><pre><code class="language-none">TypeND(T, ::Colon) = AbstractArray{&lt;:T}</code></pre><p>Sugar for creating <code>&lt;:T</code> typed array of arbitrary dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/MRphy.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.rfgr2B" href="#MRphy.rfgr2B"><code>MRphy.rfgr2B</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">B = rfgr2B(rf, gr, loc=[0 0 0]u&quot;cm&quot;; Δf=0u&quot;Hz&quot;, b1Map=1, γ=γ¹H)</code></pre><p>Turn rf, <code>rf</code>, and gradient, <code>gr</code>, into 𝐵-effective magnetic field.</p><p><em>INPUTS</em>:</p><ul><li><code>rf::TypeND(RF0D, [1,2])</code> (nT, (nCoil))</li><li><code>gr::TypeND(GR0D, [2])</code>   (nT, 3)</li><li><code>loc::TypeND(L0D, [2])</code>   (1,3) or (nM, 3), locations.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>Δf::TypeND(F0D, [0,1,2])</code> (1,)  or (nM,), off-resonance.</li><li><code>b1Map::TypeND(Union{Real,Complex},[0,1,2])</code> (1,) or (nM,(nCoils)),  transmit sensitivity.</li><li><code>γ::TypeND(Γ0D, [0,1])</code> (1,)  or (nM,), gyro-ratio</li></ul><p><em>OUTPUS</em>:</p><ul><li><code>B</code>, generator of <code>TypeND(B0D, [2])</code> (1,1,nT), 𝐵 field.</li></ul><p>See also: <a href="#MRphy.Pulse2B"><code>Pulse2B</code></a>, <a href="#MRphy.blochsim"><code>blochsim</code></a>.</p><p><strong>TODO:</strong></p><p>Support <code>loc</code>, <code>Δf</code>, and <code>b1Map</code> being <code>Base.Generators</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/beffective.jl#L5-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.Pulse2B" href="#MRphy.Pulse2B"><code>MRphy.Pulse2B</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">B = Pulse2B(pulse::Pulse, loc; Δf, b1Map, γ)</code></pre><p>Create effective magnetic field, 𝐵, from input <code>pulse</code>.</p><p>See also: <a href="#MRphy.rfgr2B"><code>rfgr2B</code></a>, <a href="#MRphy.B2UΦ"><code>B2UΦ</code></a>, <a href="#MRphy.blochsim"><code>blochsim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L276-L281">source</a></section><section><div><pre><code class="language-none">B = Pulse2B(pulse::Pulse, spa::AbstractSpinArray, loc; Δf, b1Map)</code></pre><p>...with <code>γ=spa.γ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L284-L287">source</a></section><section><div><pre><code class="language-none">B = Pulse2B(pulse::Pulse, cb::AbstractSpinCube; b1Map)</code></pre><p>...with <code>loc, Δf, γ = cb.loc, cb.Δf, cb.γ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L291-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.blochsim" href="#MRphy.blochsim"><code>MRphy.blochsim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blochsim(M, B; T1, T2, γ, dt, doHist)</code></pre><p>Same as <code>blochsim!(M, B; T1,T2,γ,dt,doHist)</code>, <code>M</code> will not be updated.</p><p>See also: <a href="#MRphy.blochsim!"><code>blochsim!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/sims.jl#L101-L106">source</a></section><section><div><pre><code class="language-none">blochsim(M, A, B)</code></pre><p>Same as <code>blochsim(M, A, B)</code>, <code>M</code> will not be updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/sims.jl#L109-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.blochsim!" href="#MRphy.blochsim!"><code>MRphy.blochsim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blochsim!(M, B; T1=(Inf)u&quot;s&quot;,T2=(Inf)u&quot;s&quot;,γ=γ¹H,dt=(4e-6)u&quot;s&quot;,doHist=false)</code></pre><p>Old school 𝐵-effective magnetic field, <code>B</code>, based bloch simulation. Globally or spin-wisely apply <code>B</code> over spins, <code>M</code>. <code>M</code> will be updated by the results.</p><p><em>INPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): input spins&#39; magnetizations.</li><li><code>B::Union{TypeND(B0D, [2,3]), Base.Generator}</code>: Global, (nT,xyz); Spin-wise, (nM,xyz,nT).</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>T1 &amp; T2 ::TypeND(T0D, [0,1])</code>: Global, (1,); Spin-wise, (nM,1).</li><li><code>γ::TypeND(Γ0D, [0,1])</code>: Global, (1,); Spin-wise, (nM, 1). gyro ratio</li><li><code>dt::T0D</code> (1,), simulation temporal step size, i.e., dwell time.</li><li><code>doHist::Bool</code>, whether to output spin history through out <code>B</code>.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): spins after applying <code>B</code>.</li><li><code>Mhst::TypeND(Real, [3])</code> (nM, xyz, nT): spins history during <code>B</code>.</li></ul><p>See also: <a href="#MRphy.applyPulse"><code>applyPulse</code></a>, <a href="#MRphy.blochsim"><code>blochsim</code></a>.</p><p><strong>Notes:</strong></p><ol><li>Not much sanity check inside this function, user is responsible for matching up the dimensions.</li><li>Put relax at the end of each time step may still be inaccurate, since physically spins relax continuously, this noise/nuance may worth study for applications like fingerprinting simulations, etc.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/sims.jl#L4-L30">source</a></section><section><div><pre><code class="language-none">blochsim!(M, A, B)</code></pre><p>Hargreave&#39;s 𝐴/𝐵, mat/vec, based bloch simulation. Globally or spin-wisely apply matrix <code>A</code> and vector <code>B</code> over spins, <code>M</code>, described in doi:10.1002/mrm.1170</p><p><em>INPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): input spins&#39; magnetizations.</li><li><code>A::TypeND(AbstractFloat,[3])</code> (nM, 3,3), <code>A[iM,:,:]</code> is the <code>iM</code>-th 𝐴.</li><li><code>B::TypeND(AbstractFloat,[2])</code> (nM, 3), <code>B[iM,:]</code> is the <code>iM</code>-th 𝐵.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): spins after applying <code>B</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/sims.jl#L87-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.B2AB" href="#MRphy.B2AB"><code>MRphy.B2AB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">B2AB(B; T1=(Inf)u&quot;s&quot;, T2=(Inf)u&quot;s&quot;, γ=γ¹H, dt=(4e-6)u&quot;s&quot;)</code></pre><p>Turn B-effective into Hargreave&#39;s 𝐴/𝐵, mat/vec, see: doi:10.1002/mrm.1170.</p><p><em>INPUTS</em>:</p><ul><li><code>B::Union{TypeND(B0D, [2,3]), Base.Generator}</code>: Global, (nT,xyz); Spin-wise, (nM,xyz,nT).</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>T1 &amp; T2 ::TypeND(T0D, [0,1])</code>: Global, (1,); Spin-wise, (nM,1).</li><li><code>γ::TypeND(Γ0D, [0,1])</code>: Global, (1,); Spin-wise, (nM, 1). gyro ratio</li><li><code>dt::T0D</code> (1,), simulation temporal step size, i.e., dwell time.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>A::TypeND(AbstractFloat,[3])</code> (nM, 3,3), <code>A[iM,:,:]</code> is the <code>iM</code>-th 𝐴.</li><li><code>B::TypeND(AbstractFloat,[2])</code> (nM, 3), <code>B[iM,:]</code> is the <code>iM</code>-th 𝐵.</li></ul><p>See also: <a href="#MRphy.rfgr2B"><code>rfgr2B</code></a>, <a href="#MRphy.Pulse2B"><code>Pulse2B</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/beffective.jl#L138-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.B2UΦ" href="#MRphy.B2UΦ"><code>MRphy.B2UΦ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">B2UΦ(B::TypeND(B0D,[2,3]); γ::TypeND(Γ0D,[0,1]), dt::T0D=4e-6u&quot;s&quot;)</code></pre><p>Given 𝐵-effective, <code>B</code>, compute rotation axis/angle, <code>U</code>/<code>Φ</code>.</p><p><em>INPUTS</em>:</p><ul><li><code>B::TypeND(B0D, [2,3])</code> (1,3,nT) or (nM, 3, nT), 𝐵 field.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>γ::TypeND(Γ0D, [0,1])</code>: Global, (1,); Spin-wise, (nM, 1). gyro ratio</li><li><code>dt::T0D</code> (1,), simulation temporal step size, i.e., dwell time.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>U::TypeND(Real, [2,3])</code> (1,3,(nT)) or (nM,3,(nT)), axis.</li><li><code>Φ::TypeND(Real, [2,3])</code> (1,1,(nT)) or (nM,1,(nT)), angle.</li></ul><p>See also: <a href="#MRphy.B2UΦ!"><code>B2UΦ!</code></a>, <a href="#MRphy.UΦRot!"><code>UΦRot!</code></a>.</p><p><strong>Notes:</strong></p><p>Somehow, in-place version, <code>B2UΦ!(B,U,Φ; γ,dt)</code>, provokes more allocs in julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/beffective.jl#L51-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.B2UΦ!" href="#MRphy.B2UΦ!"><code>MRphy.B2UΦ!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">B2UΦ!(B, U; Φ, γ, dt=(4e-6)u&quot;s&quot;)</code></pre><p>In-place version of <code>B2UΦ</code>. Somehow, <code>B2UΦ!</code>, provokes more allocs in julia.</p><p>See also: <a href="#MRphy.B2UΦ"><code>B2UΦ</code></a>, <a href="#MRphy.blochsim"><code>blochsim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/beffective.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.UΦRot" href="#MRphy.UΦRot"><code>MRphy.UΦRot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">UΦRot(U, Φ, V)</code></pre><p>Same as <code>UΦRot!(U, Φ, V, R)</code>, except not in-place.</p><p>See also: <a href="#MRphy.UΦRot!"><code>UΦRot!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/beffective.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.UΦRot!" href="#MRphy.UΦRot!"><code>MRphy.UΦRot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">UΦRot!(U, Φ, V, R)</code></pre><p>Apply axis-angle, <code>U</code>-<code>Φ</code> based rotation on <code>V</code>. Rotation is broadcasted on <code>V</code> along its 3rd dimension. Results will overwrite into <code>R</code>.</p><p><em>INPUTS</em>:</p><ul><li><code>U::TypeND(AbstractFloat,[2])</code> (nM, 3), rotation axes in 3D, assumed unitary;</li><li><code>Φ::TypeND(AbstractFloat,[1])</code> (nM,), rotation angles;</li><li><code>V::TypeND(AbstractFloat,[2,3])</code> (nM, 3, (3)), vectors to be rotated;</li><li><code>R::TypeND(AbstractFloat,[2,3])</code> (nM, 3, (3)), vectors rotated, i.e., results;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>R</code> the input container <code>R</code> is also returned for convenience.</li></ul><p>See also: <a href="#MRphy.UΦRot"><code>UΦRot</code></a>, <a href="#MRphy.B2UΦ!"><code>B2UΦ!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/beffective.jl#L98-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.applyPulse" href="#MRphy.applyPulse"><code>MRphy.applyPulse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyPulse(spa::AbstractSpinArray, p::Pulse, loc; Δf, b1Map, doHist)</code></pre><p>Turn <code>p</code> into 𝐵-effective and apply it on <code>spa.M</code>, using its own <code>M, T1, T2, γ</code>.</p><p>See also: <a href="#MRphy.blochsim"><code>blochsim</code></a>, <a href="#MRphy.freePrec"><code>freePrec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L299-L304">source</a></section><section><div><pre><code class="language-none">applyPulse(cb::AbstractSpinCube, p::Pulse; b1Map, doHist)</code></pre><p>Turn <code>p</code> into 𝐵-effective and apply it on <code>cb.M</code>, using its own <code>M, T1, T2, γ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L319-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.applyPulse!" href="#MRphy.applyPulse!"><code>MRphy.applyPulse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyPulse!(spa::AbstractSpinArray, p::Pulse, loc; Δf, b1Map, doHist)</code></pre><p>Update <code>spa.M</code> before return.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L309-L312">source</a></section><section><div><pre><code class="language-none">applyPulse!(cb::AbstractSpinCube, p::Pulse; b1Map, doHist)</code></pre><p>Update <code>cb.M</code> before return.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L327-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.freePrec" href="#MRphy.freePrec"><code>MRphy.freePrec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">freePrec(M, t; Δf, T1, T2)</code></pre><p>Same as <code>freePrec!(M, t; Δf, T1, T2)</code>, <code>M</code> will not be updated.</p><p>See also: <a href="#MRphy.freePrec!"><code>freePrec!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/sims.jl#L156-L161">source</a></section><section><div><pre><code class="language-none">freePrec(spa::AbstractSpinArray, t; Δf)</code></pre><p><code>spa::AbstractSpinArray</code> free precess by <code>t</code>. <code>spa.M</code> will not be updated.</p><p>See also: <a href="#MRphy.applyPulse"><code>applyPulse</code></a>, <a href="#MRphy.freePrec!"><code>freePrec!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L338-L343">source</a></section><section><div><pre><code class="language-none">freePrec(cb::AbstractSpinCube, t)</code></pre><p><code>cb::AbstractSpinCube</code> free precess by <code>t</code>. <code>cb.M</code> will not be updated.</p><p>See also: <a href="#MRphy.applyPulse"><code>applyPulse</code></a>, <a href="#MRphy.freePrec"><code>freePrec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L354-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.freePrec!" href="#MRphy.freePrec!"><code>MRphy.freePrec!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">freePrec!(M, t; Δf=0u&quot;Hz&quot;, T1=(Inf)u&quot;s&quot;, T2=(Inf)u&quot;s&quot;)</code></pre><p>Spins, <code>M</code>, free precess by time <code>t</code>. <code>M</code> will be updated by the results.</p><p><em>INPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): input spins&#39; magnetizations.</li><li><code>t::T0D</code> (1,): duration of free precession.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>T1 &amp; T2 ::TypeND(T0D, [0,1])</code>: Global, (1,); Spin-wise, (nM,1).</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>M::TypeND(Real, [2])</code> (nM, xyz): output spins&#39; magnetizations.</li></ul><p>See also: <a href="#MRphy.freePrec"><code>freePrec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/sims.jl#L123-L136">source</a></section><section><div><pre><code class="language-none">freePrec!(spa::AbstractSpinArray, t; Δf)</code></pre><p>...<code>spa.M</code> will updated by the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L347-L350">source</a></section><section><div><pre><code class="language-none">freePrec!(cb::AbstractSpinCube, t)</code></pre><p>...<code>cb.M</code> will be updated by the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L363-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.ExceptionImmutableField" href="#MRphy.ExceptionImmutableField"><code>MRphy.ExceptionImmutableField</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Throw <code>ArgumentError</code> when <code>$x</code> is an immutable field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/mobjs.jl#L1">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRphy.utils.CartesianLocations" href="#MRphy.utils.CartesianLocations"><code>MRphy.utils.CartesianLocations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">CartesianLocations(dim::Dims, doShift::Bool=true)</code></pre><p>Retuns a <code>(prod(dim),length(dim))</code> sized array of grid locations. <code>doShift</code> shifts the locations to be consistent with <code>fftshift</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; loc = [CartesianLocations((2,2)), CartesianLocations((2,2),false)]
2-element Array{Array{Int64,2},1}:
 [-1 -1; 0 -1; -1 0; 0 0]
 [1 1; 2 1; 1 2; 2 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/utils.jl#L10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.utils.ctrInd-Tuple{Tuple{Vararg{Int64,N}} where N}" href="#MRphy.utils.ctrInd-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>MRphy.utils.ctrInd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ctrInd(dim::Dims) = sum((dim.÷2) .* [1; cumprod([dim[1:end-1]...])])+1</code></pre><p>As a separate fn, ensure consistent behariour of getting the linear index to the center of a Nd-array of size <code>dim</code>. This <code>center</code> should match <code>fftshift</code>&#39;s <code>center</code>.</p><p>See also: <a href="#MRphy.utils.ctrSub-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>ctrSub</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/utils.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.utils.ctrSub-Tuple{Tuple{Vararg{Int64,N}} where N}" href="#MRphy.utils.ctrSub-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>MRphy.utils.ctrSub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ctrSub(dim::Dims) = CartesianIndex(dim .÷ 2 .+ 1)</code></pre><p>As a separate function, ensure consistent behaviour of getting ::CartesianIndex to the center of a Nd-Array of size <code>dim</code>. This <code>center</code> should match <code>fftshift</code>&#39;s <code>center</code>.</p><p>See also: <a href="#MRphy.utils.ctrInd-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>ctrInd</code></a>.</p><p><strong>Notes:</strong></p><p>The function may be removed once julia FFT packages provides this functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/utils.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.utils.g2k" href="#MRphy.utils.g2k"><code>MRphy.utils.g2k</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">g2k(g::TypeND(GR0D,:); isTx::Bool=false, dt::T0D=4e-6u&quot;s&quot;, γ::Γ0D=γ¹H)</code></pre><p>Compute k-space from gradient.</p><p><strong>Usage</strong></p><p><em>INPUTS</em>:</p><ul><li><code>g::TypeND(GR0D, :)</code> (nSteps, Nd...), gradient</li><li><code>isTx::Bool</code>, if <code>true</code>, compute transmit k-space, <code>k</code>, ends at the origin.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>dt::T0D</code> (1,), gradient temporal step size, i.e., dwell time.</li><li><code>γ::Γ0D</code> (1,), gyro-ratio.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>k::TypeND(K0D, :)</code> (nSteps, Nd...), k-space, w/ unit u&quot;cm^-1&quot;.</li></ul><p>See also: <a href="#MRphy.utils.k2g"><code>k2g</code></a>, <a href="#MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{T,𝐌 𝐈^-1 𝐋^-1 𝐓^-2,U} where U where T&lt;:Real)}"><code>g2s</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/utils.jl#L81-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{T,𝐌 𝐈^-1 𝐋^-1 𝐓^-2,U} where U where T&lt;:Real)}" href="#MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{T,𝐌 𝐈^-1 𝐋^-1 𝐓^-2,U} where U where T&lt;:Real)}"><code>MRphy.utils.g2s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g2s(g::TypeND(GR0D,:); dt::T0D=4e-6u&quot;s&quot;)</code></pre><p>Slew rate <code>sl</code>, of the gradient, <code>g</code>.</p><p><strong>Usage</strong></p><p><em>INPUTS</em>:</p><ul><li><code>g::TypeND(GR0D, :)</code> (nSteps, Nd...)</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>dt::T0D</code> (1,), gradient temporal step size, i.e., dwell time.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>sl::TypeND(Quantity{&lt;:Real, 𝐁/𝐋/𝐓, :)</code> (nSteps, Nd...), slew rate</li></ul><p>See also: <a href="#MRphy.utils.g2k"><code>g2k</code></a>, <a href="#MRphy.utils.k2g"><code>k2g</code></a>.</p><p><strong>Note</strong></p><p>No <code>s2g</code> is provided for the moment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/utils.jl#L101-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.utils.k2g" href="#MRphy.utils.k2g"><code>MRphy.utils.k2g</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">k2g(k::TypeND(K0D,:), isTx::Bool=false; dt::T0D=4e-6u&quot;s&quot;, γ::Γ0D=γ¹H)</code></pre><p>Gradient, <code>g</code>, of the <code>TxRx</code> k-space, (trasmit/receive, excitation/imaging).</p><p><strong>Usage</strong></p><p><em>INPUTS</em>:</p><ul><li><code>k::TypeND(K0D, :)</code> (nSteps, Nd...), Tx or Rx k-space, w/ unit u&quot;cm^-1&quot;.</li><li><code>isTx::Bool</code>, if <code>true</code>, compute transmit k-space, <code>k</code>, ends at the origin.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>dt::T0D</code> (1,), gradient temporal step size, i.e., dwell time.</li><li><code>γ::Γ0D</code> (1,), gyro-ratio.</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>g::TypeND(GR0D, :)</code> (nSteps, Nd...), gradient</li></ul><p><strong>Note</strong></p><p>The function asserts if <code>k</code> ends at the origin for <code>isTx==true</code>.</p><p>See also: <a href="#MRphy.utils.g2k"><code>g2k</code></a>, <a href="#MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{T,𝐌 𝐈^-1 𝐋^-1 𝐓^-2,U} where U where T&lt;:Real)}"><code>g2s</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/utils.jl#L57-L75">source</a></section></article><h2 id="SteadyStates"><a class="docs-heading-anchor" href="#SteadyStates">SteadyStates</a><a id="SteadyStates-1"></a><a class="docs-heading-anchor-permalink" href="#SteadyStates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRphy.SteadyStates.Signal.SPGR-Tuple{Real}" href="#MRphy.SteadyStates.Signal.SPGR-Tuple{Real}"><code>MRphy.SteadyStates.Signal.SPGR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SPGR(α; TR, T1)</code></pre><p><code>TE=0</code> Steady state SPGR signal. 10.1002/mrm.1910130109, eq.(1), ideal spoiling.</p><p><em>INPUTS</em>:</p><ul><li><code>α::Real</code> (1,), tip angle in degree;</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>TR::T0D</code> (1,), repetition time;</li><li><code>T1::T0D</code> (1,), longitudinal relaxation coefficient;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>sig::Real</code> (1,), steady-state signal.</li></ul><p>See also: <a href="#MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}"><code>bSSFP</code></a>, <a href="#MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}"><code>STFR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/SteadyStates.jl#L44-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}" href="#MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}"><code>MRphy.SteadyStates.Signal.STFR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">STFR(α, β; ϕ, Δf, T1, T2, Tg, Tf)</code></pre><p><code>TE=0</code> Steady state STFR signal. 10.1002/mrm.25146, eq.(2), ideal spoiling.</p><p><em>INPUTS</em>:</p><ul><li><code>α::Real</code> (1,), tip-down angle in degree;</li><li><code>β::Real</code> (1,), tip-up angle in degree;</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>ϕ::Real</code> (1,), phase of the tip-up pulse in radians;</li><li><code>Δf::F0D</code> (1,), off-resonance in Hz;</li><li><code>T1::T0D</code> (1,), longitudinal relaxation coefficient;</li><li><code>T2::T0D</code> (1,), transverse relaxation coefficient;</li><li><code>Tg::T0D</code> (1,), duration of gradient crusher;</li><li><code>Tf::T0D</code> (1,), duration of free precession in each TR;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>sig::Real</code> (1,), steady-state signal.</li></ul><p>See also: <a href="#MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}"><code>bSSFP</code></a>, <a href="#MRphy.SteadyStates.Signal.SPGR-Tuple{Real}"><code>SPGR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/SteadyStates.jl#L61-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}" href="#MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}"><code>MRphy.SteadyStates.Signal.bSSFP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bSSFP(α; TR, Δf, T1, T2)</code></pre><p><code>TE=0</code> Steady state bSSFP signal. 10.1002/jmri.24163, eq.(4), with <code>ϕ=2π*Δf*TR</code>.</p><p><em>INPUTS</em>:</p><ul><li><code>α::Real</code> (1,), tip angle in degree;</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>TR::T0D</code> (1,), repetition time;</li><li><code>Δf::F0D</code> (1,), off-resonance in Hz;</li><li><code>T1::T0D</code> (1,), longitudinal relaxation coefficient;</li><li><code>T2::T0D</code> (1,), transverse relaxation coefficient;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>sig::Complex</code> (1,), steady-state signal.</li></ul><p>See also: <a href="#MRphy.SteadyStates.Signal.SPGR-Tuple{Real}"><code>SPGR</code></a>, <a href="#MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}"><code>STFR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/SteadyStates.jl#L17-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SteadyStates.RFSpoiling.FZstates-Tuple{AbstractArray{D,2} where D&lt;:Real,Real}" href="#MRphy.SteadyStates.RFSpoiling.FZstates-Tuple{AbstractArray{D,2} where D&lt;:Real,Real}"><code>MRphy.SteadyStates.RFSpoiling.FZstates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FZstates(Φ, α; TR, T1, T2, FZ)</code></pre><p>𝐹, 𝑍 from: 10.1002/(SICI)1099-0534(1999)11:5&lt;291::AID-CMR2&gt;3.0.CO;2-J, eq.(7,8). eq.(7) refined to <code>÷√(2)</code>, instead of <code>÷2</code>, as in 10.1002/mrm20736: eq.(2).</p><p>Assume constant gradient spoiling of m⋅2π dephasing in each TR, m∈ℤ. In practice, if dephase is a constant but not exactly m⋅2π, the resulting states can be computed by convolving a sinc with the m⋅2π dephased results.</p><p><em>INPUTS</em>:</p><ul><li><code>Φ::TypeND(Real,[2])</code> (nC,nTR), nC: #<code>C</code> as <code>C</code> in <code>QuadPhase</code>. Typically, one simulates a range of <code>C</code>s, picking a <code>C</code> yielding a signal intensity equals to that of ideal spgr spoiling.</li><li><code>α::Real</code> (1,), flip-angle.</li></ul><p><em>KEYWORDS</em>:</p><ul><li><code>TR::T0D</code> (1,), repetition time;</li><li><code>T1::T0D</code> (1,), longitudinal relaxation coefficient;</li><li><code>T2::T0D</code> (1,), transverse relaxation coefficient;</li><li><code>FZ::NamedTuple</code>, <code>(Fs,Fcs,Zs)</code>, simulate from prescribed states if given:<br/><code>Fs ::TypeND(Complex,[2])</code>, transversal dephasing states, 𝐹ₙ;<br/><code>Fcs::TypeND(Complex,[2])</code>, conjugate transversal dephasing states, 𝐹₋ₙ*;<br/><code>Zs ::TypeND(Complex,[2])</code>, longitudinal states, 𝑍ₙ;</li></ul><p><em>OUTPUTS</em>:</p><ul><li><code>FZ::NamedTuple</code>, <code>(Fs,Fcs,Zs)</code>, simulation results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/SteadyStates.jl#L111-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRphy.SteadyStates.RFSpoiling.QuadPhase" href="#MRphy.SteadyStates.RFSpoiling.QuadPhase"><code>MRphy.SteadyStates.RFSpoiling.QuadPhase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">QuadPhase(nTR::Integer, C::Real, B::Real, A::Real)</code></pre><p>Quadratically cycling phases in (°): Φ(n) = mod.(C⋅n² + B⋅n + A, 360), n=0:nTR-1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tianrluo/MRphy.jl/blob/2d482f0f25da1c56ae8cdbd71cfeab915ab3b5c1/src/SteadyStates.jl#L104-L107">source</a></section></article><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#MRphy"><code>MRphy</code></a></li><li><a href="#MRphy.SteadyStates"><code>MRphy.SteadyStates</code></a></li><li><a href="#MRphy.SteadyStates.RFSpoiling"><code>MRphy.SteadyStates.RFSpoiling</code></a></li><li><a href="#MRphy.SteadyStates.Signal"><code>MRphy.SteadyStates.Signal</code></a></li><li><a href="#MRphy.utils"><code>MRphy.utils</code></a></li><li><a href="#MRphy.γ¹H"><code>MRphy.γ¹H</code></a></li><li><a href="#MRphy.AbstractPulse"><code>MRphy.AbstractPulse</code></a></li><li><a href="#MRphy.AbstractSpinArray"><code>MRphy.AbstractSpinArray</code></a></li><li><a href="#MRphy.AbstractSpinBolus"><code>MRphy.AbstractSpinBolus</code></a></li><li><a href="#MRphy.AbstractSpinCube"><code>MRphy.AbstractSpinCube</code></a></li><li><a href="#MRphy.B0D"><code>MRphy.B0D</code></a></li><li><a href="#MRphy.F0D"><code>MRphy.F0D</code></a></li><li><a href="#MRphy.GR0D"><code>MRphy.GR0D</code></a></li><li><a href="#MRphy.K0D"><code>MRphy.K0D</code></a></li><li><a href="#MRphy.L0D"><code>MRphy.L0D</code></a></li><li><a href="#MRphy.Pulse"><code>MRphy.Pulse</code></a></li><li><a href="#MRphy.Pulse"><code>MRphy.Pulse</code></a></li><li><a href="#MRphy.RF0D"><code>MRphy.RF0D</code></a></li><li><a href="#MRphy.SL0D"><code>MRphy.SL0D</code></a></li><li><a href="#MRphy.SpinArray-Tuple{BitArray}"><code>MRphy.SpinArray</code></a></li><li><a href="#MRphy.SpinArray"><code>MRphy.SpinArray</code></a></li><li><a href="#MRphy.SpinArray"><code>MRphy.SpinArray</code></a></li><li><a href="#MRphy.SpinBolus"><code>MRphy.SpinBolus</code></a></li><li><a href="#MRphy.SpinCube-Tuple{BitArray{3},AbstractArray{D,2} where D&lt;:(Unitful.Quantity{T,𝐋,U} where U where T&lt;:Real)}"><code>MRphy.SpinCube</code></a></li><li><a href="#MRphy.SpinCube"><code>MRphy.SpinCube</code></a></li><li><a href="#MRphy.SpinCube-Tuple{Tuple{Int64,Int64,Int64},Vararg{Any,N} where N}"><code>MRphy.SpinCube</code></a></li><li><a href="#MRphy.T0D"><code>MRphy.T0D</code></a></li><li><a href="#MRphy.Γ0D"><code>MRphy.Γ0D</code></a></li><li><a href="#MRphy.B2AB"><code>MRphy.B2AB</code></a></li><li><a href="#MRphy.B2UΦ"><code>MRphy.B2UΦ</code></a></li><li><a href="#MRphy.B2UΦ!"><code>MRphy.B2UΦ!</code></a></li><li><a href="#MRphy.ExceptionImmutableField"><code>MRphy.ExceptionImmutableField</code></a></li><li><a href="#MRphy.Pulse2B"><code>MRphy.Pulse2B</code></a></li><li><a href="#MRphy.SteadyStates.RFSpoiling.FZstates-Tuple{AbstractArray{D,2} where D&lt;:Real,Real}"><code>MRphy.SteadyStates.RFSpoiling.FZstates</code></a></li><li><a href="#MRphy.SteadyStates.RFSpoiling.QuadPhase"><code>MRphy.SteadyStates.RFSpoiling.QuadPhase</code></a></li><li><a href="#MRphy.SteadyStates.Signal.SPGR-Tuple{Real}"><code>MRphy.SteadyStates.Signal.SPGR</code></a></li><li><a href="#MRphy.SteadyStates.Signal.STFR-Tuple{Real,Real}"><code>MRphy.SteadyStates.Signal.STFR</code></a></li><li><a href="#MRphy.SteadyStates.Signal.bSSFP-Tuple{Real}"><code>MRphy.SteadyStates.Signal.bSSFP</code></a></li><li><a href="#MRphy.TypeND"><code>MRphy.TypeND</code></a></li><li><a href="#MRphy.UΦRot"><code>MRphy.UΦRot</code></a></li><li><a href="#MRphy.UΦRot!"><code>MRphy.UΦRot!</code></a></li><li><a href="#MRphy.applyPulse"><code>MRphy.applyPulse</code></a></li><li><a href="#MRphy.applyPulse!"><code>MRphy.applyPulse!</code></a></li><li><a href="#MRphy.blochsim"><code>MRphy.blochsim</code></a></li><li><a href="#MRphy.blochsim!"><code>MRphy.blochsim!</code></a></li><li><a href="#MRphy.freePrec"><code>MRphy.freePrec</code></a></li><li><a href="#MRphy.freePrec!"><code>MRphy.freePrec!</code></a></li><li><a href="#MRphy.rfgr2B"><code>MRphy.rfgr2B</code></a></li><li><a href="#MRphy.utils.CartesianLocations"><code>MRphy.utils.CartesianLocations</code></a></li><li><a href="#MRphy.utils.ctrInd-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>MRphy.utils.ctrInd</code></a></li><li><a href="#MRphy.utils.ctrSub-Tuple{Tuple{Vararg{Int64,N}} where N}"><code>MRphy.utils.ctrSub</code></a></li><li><a href="#MRphy.utils.g2k"><code>MRphy.utils.g2k</code></a></li><li><a href="#MRphy.utils.g2s-Tuple{AbstractArray{#s12,N} where N where #s12&lt;:(Unitful.Quantity{T,𝐌 𝐈^-1 𝐋^-1 𝐓^-2,U} where U where T&lt;:Real)}"><code>MRphy.utils.g2s</code></a></li><li><a href="#MRphy.utils.k2g"><code>MRphy.utils.k2g</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 10 June 2021 21:08">Thursday 10 June 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
